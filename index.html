<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Platformer - Parallax, Coins & Hellgate</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
   <style>
@media screen and (orientation: portrait) {
  body::before {
    content: "Please rotate your device";
   
    background: #000;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 32px;
    z-index: 99999;
    width: 100%;
    height: 100%;
  }
}
</style>

  </head>
  <body>
    <script>
      class MainScene extends Phaser.Scene {
        constructor() {
          super("main");
        }

        preload() {
          // Hell gate image (coloque hell.png na mesma pasta do HTML)
          this.load.image("hellgate", "hell.png");
        }

        create() {
          // ---- TEXTURES / GENERATED ART ----
          this.createTextures();

          // ---- WORLD & CAMERA ----
          const WORLD_W = 4000;
          const WORLD_H = 600;
          this.physics.world.setBounds(0, 0, WORLD_W, WORLD_H);
          this.cameras.main.setBounds(0, 0, WORLD_W, WORLD_H);

          // ---- PARALLAX BACKGROUND (tileSprites usando texturas geradas) ----
          // We'll add tileSprites that we move manually according to camera.scrollX with different factors
          this.bgFar = this.add
            .tileSprite(0, 0, WORLD_W, WORLD_H, "bg_far")
            .setOrigin(0)
            .setScrollFactor(0);
          this.bgMid = this.add
            .tileSprite(0, 0, WORLD_W, WORLD_H, "bg_mid")
            .setOrigin(0)
            .setScrollFactor(0);
          this.bgNear = this.add
            .tileSprite(0, 0, WORLD_W, WORLD_H, "bg_near")
            .setOrigin(0)
            .setScrollFactor(0);
          this.bgFront = this.add
            .tileSprite(0, 0, WORLD_W, WORLD_H, "bg_front")
            .setOrigin(0)
            .setScrollFactor(0);

          // ---- Hellgate in the center (y adjusted to sit near ground) ----
          this.hellgate = this.physics.add.sprite(2000, 520, "hellgate");
          // ensure it's above background but below HUD and gameplay
          this.hellgate.setScale(0.3);
          this.hellgate.setDepth(0.5);
          this.hellgate.body.setAllowGravity(false);
          this.hellgate.body.setImmovable(true);
          this.hellgate.body.moves = false; // IMPORTANT

          // ---- PLATFORMS ----
          this.platforms = this.physics.add.staticGroup();
          // Ground segments spaced across the map
          for (let x = 200; x <= 3800; x += 400) {
            // create many ground pieces to make continuous floor
            const g = this.platforms.create(x, 580, "ground").refreshBody();
            // adjust body size (generated ground is 200 wide)
            g.body.setSize(g.width, g.height);
          }

          // Upper platforms (existing + extra to create many vertical ways up)
          const upperPlatforms = [
            { x: 600, y: 460, w: 160 },
            { x: 900, y: 360, w: 120 },
            { x: 1200, y: 460, w: 160 },

            { x: 1400, y: 380, w: 140 },
            { x: 1600, y: 420, w: 160 },
            { x: 1900, y: 320, w: 120 },
            { x: 2200, y: 420, w: 160 },

            { x: 2400, y: 300, w: 160 },
            { x: 2600, y: 480, w: 160 },
            { x: 2900, y: 380, w: 120 },
            { x: 3200, y: 300, w: 160 },

            // extra upper tiers for more vertical paths
            { x: 500, y: 250, w: 200 },
            { x: 900, y: 200, w: 160 },
            { x: 1300, y: 250, w: 200 },
            { x: 1800, y: 180, w: 180 },
            { x: 2100, y: 240, w: 200 },
            { x: 3000, y: 180, w: 200 },
            { x: 3400, y: 230, w: 160 },
            { x: 3700, y: 200, w: 180 },
          ];

          upperPlatforms.forEach((p, idx) => {
            const key = "plat" + p.w;
            if (!this.textures.exists(key)) {
              const gg = this.make.graphics({ x: 0, y: 0, add: false });
              gg.fillStyle(0x5b361f, 1);
              gg.fillRect(0, 0, p.w, 24);
              gg.generateTexture(key, p.w, 24);
              gg.destroy();
            }
            const plat = this.platforms.create(p.x, p.y, key).refreshBody();
            plat.body.setSize(p.w, 24);
          });

          // ---- PLAYER ----
          this.player = this.physics.add.sprite(100, 450, "player");
          this.player.setCollideWorldBounds(true);
          this.player.setDepth(5);
          this.player.facing = 1;
          this.player.swordActive = false;
          this.player.canAttack = true;
          this.physics.add.collider(this.player, this.platforms);

          this.cameras.main.startFollow(this.player, true, 0.08, 0.08);

          // ---- ENEMIES ----
          this.enemies = this.physics.add.group();
          const enemyPositions = [
            { x: 400, y: 540 },
            { x: 700, y: 540 },
            { x: 1000, y: 540 },
            { x: 1400, y: 400 },
            { x: 1700, y: 360 },
            { x: 2000, y: 540 },
            { x: 2300, y: 380 },
            { x: 2600, y: 540 },
            { x: 2900, y: 320 },
            { x: 3200, y: 260 },
            { x: 3500, y: 540 },
            { x: 3700, y: 520 },
          ];
          enemyPositions.forEach((pos, i) => {
            const e = this.enemies.create(pos.x, pos.y, "enemy");
            e.setCollideWorldBounds(true);
            e.setDepth(4);
            e.dir = i % 2 ? -1 : 1;
            e.speed = 40 + (i % 3) * 10;
            // patrol zone around initial x (prevents walking too far)
            e.minX = Math.max(50, pos.x - 140);
            e.maxX = Math.min(WORLD_W - 50, pos.x + 140);
            // small body size tweaks if needed
            e.body.setSize(28, 36);
          });
          this.physics.add.collider(this.enemies, this.platforms);

          // ---- SWORD (invisible physics object) ----
          this.sword = this.add
            .rectangle(0, 0, 40, 8, 0xffffff)
            .setVisible(false);
          this.physics.add.existing(this.sword);
          this.sword.body.allowGravity = false;
          this.sword.setDepth(6);

          // Sword hits enemy
          this.physics.add.overlap(this.sword, this.enemies, (s, e) => {
            if (this.player.swordActive && e.active) {
              e.destroy();
            }
          });

          // Player hit by enemy
          this.physics.add.collider(this.player, this.enemies, () => {
            this.endGame("Game Over");
          });

          // Player hit hell with 666
          this.physics.add.collider(this.player, this.hellgate, () => {
            if (this.score == 666) this.endGame("666");
          });

          // ---- COINS (three types: default, yellow, red) ----
          // default coins (+10)
          this.coins = this.physics.add.group();
          for (let x = 200; x < 3800; x += 300) {
            const c = this.coins.create(x, 0, "coin");
            c.setBounceY(Phaser.Math.FloatBetween(0.3, 0.6));
          }
          // coins on upper platforms (some)
          const coinsOnUpper = [
            { x: 600, y: 420 },
            { x: 900, y: 320 },
            { x: 1200, y: 420 },
            { x: 1600, y: 380 },
            { x: 1900, y: 280 },
            { x: 2200, y: 380 },
            { x: 2900, y: 340 },
            { x: 3200, y: 260 },
          ];
          coinsOnUpper.forEach((cpos) => {
            const cc = this.coins.create(cpos.x, cpos.y, "coin");
            cc.setBounceY(0);
          });
          this.physics.add.collider(this.coins, this.platforms);
          this.physics.add.overlap(this.player, this.coins, (p, c) => {
            c.disableBody(true, true);
            this.score += 37;
            this.updateScoreText();
          });

          // YELLOW COINS (+37)
          this.yellowCoins = this.physics.add.group();
          for (let x = 350; x < 3800; x += 450) {
            const yc = this.yellowCoins.create(x, 0, "coin_yellow");
            yc.setBounceY(Phaser.Math.FloatBetween(0.2, 0.5));
          }
          // a few on upper plats
          [
            { x: 1300, y: 220 },
            { x: 2100, y: 200 },
            { x: 3000, y: 160 },
          ].forEach((p) => {
            const yc = this.yellowCoins.create(p.x, p.y, "coin_yellow");
            yc.setBounceY(0);
          });
          this.physics.add.collider(this.yellowCoins, this.platforms);
          this.physics.add.overlap(this.player, this.yellowCoins, (p, c) => {
            c.disableBody(true, true);
            this.score += 37;
            this.updateScoreText();
          });

          // RED COINS (-18)
          this.redCoins = this.physics.add.group();
          for (let x = 250; x < 3800; x += 600) {
            const rc = this.redCoins.create(x, 0, "coin_red");
            rc.setBounceY(Phaser.Math.FloatBetween(0.2, 0.6));
          }
          // some on upper plats
          [
            { x: 800, y: 300 },
            { x: 2400, y: 260 },
            { x: 3400, y: 200 },
          ].forEach((p) => {
            const rc = this.redCoins.create(p.x, p.y, "coin_red");
            rc.setBounceY(0);
          });
          this.physics.add.collider(this.redCoins, this.platforms);
          this.physics.add.overlap(this.player, this.redCoins, (p, c) => {
            c.disableBody(true, true);
            this.score -= 37;
            if (this.score < 0) this.score = 0;
            this.updateScoreText();
          });

          // ---- INPUT ----
          this.cursors = this.input.keyboard.createCursorKeys();
          this.keyShift = this.input.keyboard.addKey(
            Phaser.Input.Keyboard.KeyCodes.SHIFT
          );
          this.keyF = this.input.keyboard.addKey(
            Phaser.Input.Keyboard.KeyCodes.F
          );

          // ---- MOBILE HUD (fixed to camera) ----
          this.createButtons();

          // ---- UI / SCORE ----
          this.score = 0;
          this.scoreText = this.add
            .text(20, 20, "Score: 0", { fontSize: "24px", color: "#fff" })
            .setScrollFactor(0)
            .setDepth(1000);

          // overlay for end game
          this.overlay = this.add.rectangle(0, 0, 2000, 2000, 0x000000)
  .setOrigin(0)
  .setAlpha(0)
  .setDepth(9999)
  .setScrollFactor(0);
          this.overlay.setOrigin(0.5);
          this.ending = false;
        }

        createTextures() {
          // create simple textures for backgrounds, ground and coins
          const g = this.add.graphics();

          // far background (mountains)
          g.fillStyle(0x6b8cff, 1);
          g.fillRect(0, 0, 800, 600);
          g.fillStyle(0x556bde, 1);
          g.fillRect(0, 350, 800, 120);
          g.generateTexture("bg_far", 800, 600);

          // mid background (hills)
          g.clear();
          g.fillStyle(0x7fbf7f, 1);
          g.fillRect(0, 0, 800, 600);
          g.fillStyle(0x5da35d, 1);
          g.fillEllipse(200, 420, 500, 150);
          g.fillEllipse(600, 420, 500, 150);
          g.generateTexture("bg_mid", 800, 600);

          // near background (buildings/trees)
          g.clear();
          g.fillStyle(0x9fc1a1, 1);
          g.fillRect(0, 0, 800, 600);
          // simple shapes as decorations
          g.fillStyle(0x3b2f2f, 1);
          g.fillRect(60, 320, 40, 120);
          g.fillRect(720, 300, 40, 140);
          for (let i = 0; i < 6; i++) {
            g.fillRect(
              120 + i * 100,
              340 - (i % 3) * 40,
              30,
              100 + (i % 2) * 30
            );
          }
          g.generateTexture("bg_near", 800, 600);

          // front ground detail
          g.clear();
          g.fillStyle(0x87a86a, 1);
          g.fillRect(0, 0, 800, 600);
          g.generateTexture("bg_front", 800, 600);

          // player / enemy / coin / ground textures
          g.clear();
          g.fillStyle(0x0080ff, 1);
          g.fillRect(0, 0, 30, 40);
          g.generateTexture("player", 30, 40);

          g.clear();
          g.fillStyle(0xff0000, 1);
          g.fillRect(0, 0, 30, 40);
          g.generateTexture("enemy", 30, 40);

          // default coin (yellow-ish, +10)
          g.clear();
          g.fillStyle(0xffd700, 1);
          g.fillCircle(10, 10, 10);
          g.generateTexture("coin", 20, 20);

          // coin yellow (bright) +37
          g.clear();
          g.fillStyle(0xffff66, 1);
          g.fillCircle(10, 10, 10);
          g.generateTexture("coin_yellow", 20, 20);

          // coin red (-18)
          g.clear();
          g.fillStyle(0xff4444, 1);
          g.fillCircle(10, 10, 10);
          g.generateTexture("coin_red", 20, 20);

          // ground
          g.clear();
          g.fillStyle(0x654321, 1);
          g.fillRect(0, 0, 200, 40);
          g.generateTexture("ground", 200, 40);

          g.destroy();
        }

        createButtons() {
          // HUD coordinates relative to screen; fixed with setScrollFactor(0)
          const hudY = this.cameras.main.height - 100;
          this.btnLeft = this.add
            .text(40, hudY, "◀", { fontSize: "100px", color: "#fff" })
            .setInteractive({ useHandCursor: true })
            .setScrollFactor(0)
            .setDepth(1000);
          this.btnRight = this.add
            .text(220, hudY, "▶", { fontSize: "100px", color: "#fff" })
            .setInteractive({ useHandCursor: true })
            .setScrollFactor(0)
            .setDepth(1000);
          this.btnJump = this.add
            .text(this.cameras.main.width - 120, hudY - 10, "↑", {
              fontSize: "100px",
              color: "#fff",
            })
            .setInteractive({ useHandCursor: true })
            .setScrollFactor(0)
            .setDepth(1000);
          this.btnAtk = this.add
            .text(this.cameras.main.width - 280, hudY, "⚔", {
              fontSize: "100px",
              color: "#fff",
            })
            .setInteractive({ useHandCursor: true })
            .setScrollFactor(0)
            .setDepth(1000);

          // movement state
          this.moveDir = 0;

          // left handlers
          this.btnLeft.on("pointerdown", () => {
            this.moveDir = -1;
          });
          this.btnLeft.on("pointerup", () => {
            this.moveDir = 0;
          });
          this.btnLeft.on("pointerout", () => {
            this.moveDir = 0;
          });
          this.btnLeft.on("pointerupoutside", () => {
            this.moveDir = 0;
          });

          // right handlers
          this.btnRight.on("pointerdown", () => {
            this.moveDir = 1;
          });
          this.btnRight.on("pointerup", () => {
            this.moveDir = 0;
          });
          this.btnRight.on("pointerout", () => {
            this.moveDir = 0;
          });
          this.btnRight.on("pointerupoutside", () => {
            this.moveDir = 0;
          });

          // jump & attack
          this.btnJump.on("pointerdown", () => this.jump());
          this.btnAtk.on("pointerdown", () => this.attack());

        }

        jump() {
          if (this.player.body.onFloor()) {
            this.player.setVelocityY(-450);
          }
        }

        attack() {
          if (!this.player.canAttack) return;
          this.player.canAttack = false;
          this.player.swordActive = true;

          const offset = this.player.facing * 30;
          this.sword.setPosition(this.player.x + offset, this.player.y);
          this.sword.setVisible(true);

          this.time.delayedCall(200, () => {
            this.sword.setVisible(false);
            this.player.swordActive = false;
          });
          this.time.delayedCall(500, () => (this.player.canAttack = true));
        }

        updateScoreText() {
          this.scoreText.setText("Score: " + this.score);
        }

        update(time, delta) {
          if (this.ending) return;

          // ---- PARALLAX SCROLLING ----
          // Move tileSprites' tilePosition based on camera scroll with different multipliers
          const camX = this.cameras.main.scrollX;
          this.bgFar.tilePositionX = camX * 0.15;
          this.bgMid.tilePositionX = camX * 0.35;
          this.bgNear.tilePositionX = camX * 0.6;
          this.bgFront.tilePositionX = camX * 0.9;

          // ---- PLAYER MOVEMENT ----
          let dir = 0;
          if (this.cursors.left.isDown) dir = -1;
          else if (this.cursors.right.isDown) dir = 1;
          else dir = this.moveDir;

          this.player.setVelocityX(dir * 180);
          if (dir !== 0) this.player.facing = dir;

          // Jump input
          if (
            (this.cursors.up.isDown || this.cursors.space.isDown) &&
            this.player.body.onFloor()
          ) {
            this.jump();
          }

          // Attack with Shift or F
          if (
            Phaser.Input.Keyboard.JustDown(this.keyShift) ||
            Phaser.Input.Keyboard.JustDown(this.keyF)
          ) {
            this.attack();
          }

          // Sword follows player during attack
          if (this.player.swordActive) {
            this.sword.setPosition(
              this.player.x + this.player.facing * 30,
              this.player.y
            );
          }

          // ---- ENEMY AI: patrol, avoid falling, jump on wall collide ----
          this.enemies.children.iterate((e) => {
            if (!e || !e.active) return;

            // set horizontal velocity
            e.setVelocityX(e.dir * e.speed);

            // If colliding with world bounds (wall), flip and jump
            if (e.body.blocked.left) {
              e.dir = 1;
              if (e.body.onFloor()) e.setVelocityY(-220);
            } else if (e.body.blocked.right) {
              e.dir = -1;
              if (e.body.onFloor()) e.setVelocityY(-220);
            }

            // EDGE DETECTION: check a point ahead+below to see if a platform exists there
            const lookAheadX = e.x + e.dir * 20;
            const footY = e.y + 22; // a bit below enemy center
            let platformAhead = false;

            // iterate platforms to see if any top surface exists under next point
            this.platforms.children.iterate((p) => {
              if (!p || !p.body) return;
              const px1 = p.body.x;
              const px2 = p.body.x + p.body.width;
              const py = p.body.y;
              // If lookAheadX sits horizontally within platform AND footY is slightly above platform top
              if (
                lookAheadX > px1 &&
                lookAheadX < px2 &&
                footY < py + 30 &&
                footY > py - 60
              ) {
                platformAhead = true;
              }
            });

            if (!platformAhead && e.body.onFloor()) {
              // turn before falling
              e.dir *= -1;
            }

            // keep enemy within its patrol bounds (minX/maxX) too
            if (e.x <= e.minX) {
              e.dir = 1;
              if (e.body.onFloor()) e.setVelocityY(-180);
            } else if (e.x >= e.maxX) {
              e.dir = -1;
              if (e.body.onFloor()) e.setVelocityY(-180);
            }
          });

          // OPTIONAL: keep HUD fixed (already scrollFactor 0)
        }

        endGame(msg) {
  if (this.ending) return;
    this.ending = true;
  const trueEnding = msg == "666";
  // special message
  if (trueEnding) {  
    this.scoreText = this.add.text(
        100, 
        200, 
        "Somente a luz\nnegra pode revelar a verdadeira\nmensagem do cavaleiro",
        { fontSize: "32px", color: "#fff" }
    )
    .setScrollFactor(0)
    .setDepth(20000);
  }

  this.physics.pause();

  // resize overlay to full screen
  this.overlay.setDisplaySize(
    this.cameras.main.width,
    this.cameras.main.height
  );

  // center overlay based on camera
  this.overlay.x = this.cameras.main.x + this.cameras.main.width / 2;
  this.overlay.y = this.cameras.main.y + this.cameras.main.height / 2;

  // fade in black
  this.tweens.add({
    targets: this.overlay,
    alpha: 1,
    duration: 1200,
    ease: "Linear",
    onComplete: () => {
      this.add.text(
        this.cameras.main.midPoint.x,
        this.cameras.main.midPoint.y,
        msg,
        { fontSize: "40px", color: "#fff" }
      )
      .setOrigin(0.5)
      .setScrollFactor(0)
      .setDepth(2001);

      if (!trueEnding) this.time.delayedCall(3000, () => this.scene.restart());
    }
  });
}

      }

      const config = {
  type: Phaser.AUTO,
  
  parent: "game",
  backgroundColor: "#000",
  width: 1280,
  height: 720,

  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    orientation: Phaser.Scale.LANDSCAPE,
    width: 1280,
  height: 720,
  },
  input: {
    activePointers: 3,
  },

  physics: {
    default: "arcade",
    arcade: {
      gravity: { y: 600 },
      debug: false,
    },
  },

  scene: [MainScene],
};

      new Phaser.Game(config);
    </script>
  </body>
</html>
